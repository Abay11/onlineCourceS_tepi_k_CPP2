Выберите верные утверждения.

 + Если некоторый тип можно хранить в set, то он же может быть ключом в map.
 Элементы в unordered_set хранятся в порядке их добавления в контейнер.
 + При поиске в set всегда просматривается O(log n) элементов контейнера.
 При поиске в unordered_set всегда просматривается O(1) элементов контейнера.
 Если некоторый тип можно хранить в set, то он же может быть ключом в unordered_map.
 В set можно хранить только такие типы, для которых определён operator<.


 1)  При поиске в unordered_set всегда просматривается O(1) элементов контейнера.

 Хеш-функция может выдавать индекс, по которому уже будет что-то храниться в таблице.
 Это называется коллизиями. Если коллизий много,
 то алгоритму поиска придется перебирать более одного элемента в поисках совпадений.

 2)  Если некоторый тип можно хранить в set, то он же может быть ключом в unordered_map.

 unordered_map - это хеш-таблица,
 а хранение в ней связано только с работой хеш-функции от значений ключа. Связи не видно.

 3)  Если некоторый тип можно хранить в set, то он же может быть ключом в map.

 map - это такой set, у которого есть еще кармашек для значения. Ключом в set является само значение,
 для которого требуется наличие отношения порядка (operator<).

 4)  Элементы в unordered_set хранятся не в порядке возрастания, а в порядке добавления.

 unordered_set  - это хеш-таблица, у которой порядок определяется индексом, рассчитываемым хеш-функцией.

 5) В set можно хранить только такие типы, для которых определён оператор <.
  Можно определить собственный компаратор, но не определять оператор <

 ﻿6)  При поиске в set всегда просматривается O(log n) элементов контейнера.
 set - это дерево поиска. В худшем случае пройдем высоту дерева. Если дерево сбалансировано (каким является set),
 то высотой дерева станет log(n), где n - число элементов.


